Q1：哪些寄存器保存函数参数？例如，在main函数对printf的调用中，哪个寄存器保存13？
答：通过call.asm文件的第45,46行可知，a1、a2等通用寄存器保存函数参数，13被寄存器a2保存。

Q2：main函数的汇编代码中对函数f的调用在哪里？对g的调用在哪里？（提示：编译器可能会将函数内联）
答：通过查看main函数的代码，可以看到在printf中调用了函数f，但是在汇编代码中，f(8)+1直接被替换为12存放在寄存器中，所以main函数并未调用函数f和g，而是由编译器进行了优化。

Q3：printf函数的地址是什么？
答：在第1088行可以看到printf函数的地址为0x628。

Q4：在main函数中，printf的jalr之后的寄存器ra中的值是什么？
答：在第49行，auipc ra,0x0指令将当前程序计数器pc的值存入ra中。然后jalr指令跳转到偏移地址printf处，即0x628。在执行完毕后，寄存器ra的值被设置为pc+4,即返回地址0x38。

Q5：运行以下代码：unsigned int i = 0x00646c72;
		 printf("H%x Wo%s", 57616, &i);
1)程序的输出是什么？
答：程序的输出是He110 World

2)这样的输出取决于RISC-V小端存储，若RISC-V是大端存储，为了得到相同的输出，i应被设置为什么？57616是否需要更改？
答：57616被转换为十六进制的e110，所以格式化描述副%x打印出它的十六进制表示。在小端处理器中，数据0x00646c72的高字节存储在内存高位，低字节存储在低位，所以从低位开始读取，对应的ASCII字符为rld；在大端处理器中，情况恰好相反，高字节被存储在内存低位，所以读取时的结果为dlr，要得到相同的输出内容，需要将i的值设为0x726c64。无论在大端还是小端，57616的十六进制都是e110,因为大小端改变的只是多字节数据在内存中的存放方式，不改变值的大小，所以无需更改57616。

Q6：执行printf("x=%d y=%d", 3);y=后面的值是什么？（是一个不可预知值）为什么会出现这样的情况？
答：由先前的知识可知，函数参数存放在通用寄存器中，但是printf中缺少一个参数，那么它仍然会从一个特定的寄存器中读取一个参数值，而该寄存器中的数据是未被指定的，所以是一个不可预知的结果。
